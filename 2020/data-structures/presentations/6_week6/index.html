<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="utf-8">
    <title>Week 6: Recursion, Big-Oh Notation, Queue Applications</title>

    <link rel="stylesheet" href="/css/font-awesome.min.css">

    

    <link rel="stylesheet" href="/css/laminal.css">


    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            processEscapes: true
          }
        });
        </script>
</head>

<body>

    <textarea id="source">

---
## Recursion

### Factorial example

<img src="/gallery/recursion1.gif" style="width:100%" />


---
```c++
#include <iostream>
int factorial( int n )
{
    if( n &lt;= 1 )
        return 1;
    else
        return n * factorial( n - 1 );
}

int main()
{
    std::cout &lt;&lt; "5!=" &lt;&lt; factorial( 5 );
    return 0;
}
```

---
```python
factorial(5) 
   factorial(4) 
      factorial(3) 
         factorial(2) 
            factorial(1) 
               return 1 
            return 2*1 = 2 
         return 3*2 = 6 
      return 4*6 = 24 
   return 5*24 = 120
```

---
<img src="/gallery/fact5rec/8.svg" style="width:100%;" />

---
<img src="/gallery/fact5rec/7.svg" style="width:100%;" />

---
<img src="/gallery/fact5rec/6.svg" style="width:100%;" />

---
<img src="/gallery/fact5rec/6.svg" style="width:100%;" />

---
<img src="/gallery/fact5rec/5.svg" style="width:100%;" />

---
<img src="/gallery/fact5rec/4.svg" style="width:100%;" />

---
<img src="/gallery/fact5rec/3.svg" style="width:100%;" />

---
<img src="/gallery/fact5rec/2.svg" style="width:100%;" />

---
<img src="/gallery/fact5rec/1.svg" style="width:100%;" />



---
### How recursion work in stack memory

[{Demo: How Recursive Factorial Work in Memory}](https://www.cs.usfca.edu/~galles/visualization/RecFact.html)

---
### Recursion is not Function Overloading

--
The following is not recursion

```c++
struct Rectangle
{
    double a = 0;
    double b = 0;
};

double area( double a , double b )
{
    return a * b;
}

double area( Rectangle rect )
{
    return area( rect.a , rect.b ); // This is not recursion.
}
```

---
However, the following calling `area` is recursive, it calls itself

```c++
struct Rectangle
{
    double a = 0;
    double b = 0;
};

double area( Rectangle rect )
{
    return area( rect ); // This is a recursion. Very pointless and buggy function!
}
```

* infinite recurions, 
* until .red[stack memory overflow] happens, 
* and finally the program crashes.
* pointless function.
--
* **Add to your glossary**: *[Stack Memory Overflow](https://en.wikipedia.org/wiki/Stack_overflow)*

---
### **Exercise**: Power Function

--
Implement a function `power` that uses recursion to compute the power of the input number.


---
### Recursion is very important technique

--
* Tree data structure.
--
* Divide and conquer &amp; dynamic programming algorithms.
--
* Elegant functions with less codes.

---
## Big-Oh Notation

--
### What is an Algorithm

--
&gt; According to Donald Knuth, the word *algorithm* is derived from the name “al-Khowârizmı̂,” a ninth-century Persian mathematician.

--
#### In programming, 

--
* *algorithm* is a function with clever logic. 
--
* However, it is a very general term. 
--
* The `meanArray` function is an *algorithm 
--
* Similary, `varianceArray`, `minArray`, `maxArray`, `factorial`, and `power`.


--
We are concerned about the function running time w.r.t input size `n`.

---
### How to measure an algorithm performance

#### Constant Performance


--
```c++
int sqaure( int x )
{
    int y = x * x; // T1(n) = 1
    return y; // T2(n) = 1
}
```

--
$$ T(n) = T1 + T2 = 2 $$


--
$$ O( T(n) ) = O(2) = O(1) $$


--
**constant execution time**. 


---
#### Constant Performance

```c++
bool isEmpty( CharacterStackLL &amp;stack )
{
    return stack.front == nullptr; // T(n) = 1
}
```

--
$$ T(n) = 1 $$

--
$$ O( T(n) ) = O(1) $$


--
*Related terms: Performance, complexity, growth function*


---
#### Linear Performance


--
```c++
void printLL( Node* front )
{
    Node *current = front; // T1(n) = 1

    while( current != nullptr ) // T2(n) = n * ( T3 + T4 )
    {
        std::cout &lt;&lt; current-&gt;data; // T3(n) = 1
        current = current-&gt;next; // T4(n) = 1
    }
}
```
--
$$  T(n) = T1 + T2 = 1 + n ( T3 + T4 ) = 1 + 2n $$


--
$$ O(T(n)) = O( 1 + 2n ) = O(n) $$


--
* linear in execution time.

---

<img src="/gallery/complexity.svg" style="width:80%;" />

---
* How to approximately estimate the function running time for $n=1000000$, i.e linked-list of **1-million** element
* **Givens**:

    * The function has complexity of $ O(n) $.
    * The function executed in *2 melliseconds* when $n=2000$.


---
#### Quadratic Performance

Consider the following **naive** inefficient function `varianceArray`

--
```c++
double varianceArray( double *base, int arraySize )
{
    double sum = 0 ;
    for( int i = 0; i &lt; arraySize ; ++i ) 
    {
        double diff = meanArray(&amp;base[0],arraySize ) - base[i]; 
        sum = sum + diff * diff ; 
    }
    return sum / arraySize;
}
```

--
* `std::vector&lt; double &gt;` version?

---
#### Quadratic Performance

Consider the following **naive** inefficient function `varianceArray`


```c++
double varianceArray( std::vector&lt; double &gt; &amp;array )
{
    double sum = 0 ;
    for( int i = 0; i &lt; array.size() ; ++i ) 
    {
        double diff = meanArray( array ) - array[i]; 
        sum = sum + diff * diff ;
    }
    return sum / array.size();
}
```

--
* Analyse lines

---
#### Quadratic Performance

Consider the following **naive** inefficient function `varianceArray`


```c++
double varianceArray( std::vector&lt; double &gt; &amp;array )
{
    double sum = 0 ; // T1(n) = 1
    for( int i = 0; i &lt; array.size() ; ++i ) // T2(n) = n ( T3 + T4 )
    {
        double diff = meanArray( array ) - array[i]; // T3(n) = n
        sum = sum + diff * diff ; // T4(n) = 1
    }
    return sum / array.size(); // T5(n) = 1
}
```

--
$$  T(n) = T1 + T2 + T5 = 1 + n ( T3 + T4 ) + 1 = 1 + n( n + 1 ) + 1$$ 
$$ = n^2 + n + 2 $$

$$ O(T(n)) = O(n^2 + n + 2) = O(n^2) $$

---
#### Quadratic Performance

Consider the following **naive** inefficient function `varianceArray`


```c++
double varianceArray( std::vector&lt; double &gt; &amp;array )
{
    double sum = 0 ; // T1(n) = 1
    for( int i = 0; i &lt; array.size() ; ++i ) // T2(n) = n ( T3 + T4 )
    {
        double diff = meanArray( array ) - array[i]; // T3(n) = n
        sum = sum + diff * diff ; // T4(n) = 1
    }
    return sum / array.size(); // T5(n) = 1
}
```

.red[Can we do better?]

---
#### Quadratic Performance

.green[mean is constant for the same array!]


```c++
double varianceArray( std::vector&lt; double &gt; &amp;array  )
{
    double sum = 0 ; // T1(n) = 1
    double mean = meanArray( array ); // T2(n) = O(n)
    for( int i = 0; i &lt; array.size() ; ++i ) // T2(n) = n ( T3 + T4 )
    {
        double diff = mean - array[i]; // T3(n) = 1
        sum = sum + diff * diff ; // T4(n) = 1
    }
    return sum / array.size(); // T5(n) = 1
}
```

--
$$  T(n) = T1 + T2 + T5 = 1 + n ( T3 + T4 ) + 1 = 1 + n( 1 + 1 ) + 1$$ 
$$ = 2n + 2 $$

$$ O(T(n)) = O(2n + 2) = O(n) $$

---
#### Quadratic Performance

##### Again..


```c++
double varianceArray( std::vector&lt; double &gt; &amp;array  )
{
    double sum = 0 ; // T1(n) = 1
    double mean = meanArray( array ); // T2(n) = O(n)
    for( int i = 0; i &lt; array.size() ; ++i ) // T2(n) = n ( T3 + T4 )
    {
        double diff = mean - array[i]; // T3(n) = 1
        sum = sum + diff * diff ; // T4(n) = 1
    }
    return sum / array.size(); // T5(n) = 1
}
```

.red[Can we do better in sense of safety?]

---
#### Quadratic Performance

##### const-correctness


```c++
double varianceArray( const std::vector&lt; double &gt; &amp;array  )
{
    double sum = 0 ; // T1(n) = 1
    double mean = meanArray( array ); // T2(n) = O(n)
    for( int i = 0; i &lt; array.size() ; ++i ) // T2(n) = n ( T3 + T4 )
    {
        double diff = mean - array[i]; // T3(n) = 1
        sum = sum + diff * diff ; // T4(n) = 1
    }
    return sum / array.size(); // T5(n) = 1
}
```



---
### Further: Orders of common functions

<img src="/gallery/complexity.svg" style="width:80%;" />


---
[{Orders of common functions}](https://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions)


---
### Exercises

```c++

// n = input array `sequence` size
int countCharacter( const std::string &amp;sequence , char query )
{
    int x = 0; // T1(n) = 1
    for ( int i = 0; i &lt; sequence.size(); ++i) // T2(n) = n * T3(n)
    {
        if ( query == sequence[i] ) T3(n) = 1
            ++x;
    }
    return x; // T4(n) = 1
}
// T(n) = T1 + T2 + T4 = 1 + n * T3 + 1 = 2 + n
// O(T(n)) = O(n)
```


---
```c++
char *analyzeDNA( const std::string &amp;sequence, int &amp;countA, int &amp;countC, int &amp;countG, int countT)
{
    countA = arrays::countCharacter( sequence, 'A'); // T1(n) = 2 + n =&gt; O(n)
    countC = arrays::countCharacter( sequence, 'C'); // T2 = same
    countG = arrays::countCharacter( sequence, 'G'); // T3 = same
    countT = arrays::countCharacter( sequence, 'T'); // T4 = same
    return complementarySequence( sequence ); // T5 = 1
}

// T(n) = 4 * (2 + n) + 1 = 9 + 4n
// O(T(n)) = O(n)
```

---
## Sorting Algorithms

--
**Problem** given a collection of **n** elements, it is required to sort the elements in ascending order.

--
* **Example** the following arbitrary array:

| 1 | 9 | 4 | 7 | 3 |

--
* After applying sorting in ascending order will result as:


| 1 | 3 | 4 | 7 | 9 |

---
### Bubble Sort

--
#### Visualized Bubble Sort 1

<iframe width="560" height="315" src="/gallery/bubblesort.mp4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""></iframe>

---
#### Visualized Bubble Sort 2

<img src="/gallery/Bubble-sort-example-300px.gif" />
&gt; Credits: [CC BY-SA 3.0](https://commons.wikimedia.org/w/index.php?title=User:Swfung8&amp;action=edit&amp;redlink=1)

---
#### Implementation

```c++
#include <algorithm>
// A function to implement bubble sort
void bubbleSort( std::vector&lt; double &gt; &amp;array )
{
    for ( int i = 0; i &lt; array.size()-1; i++ )
    {
        for ( int j = 0; j &lt; array.size()-1; j++ )
        {
            if ( array[j] &gt; arr[j+1])
                std::swap( array[j] , array[j+1] );
        }
    }
}
```

---
#### Complexity Analysis

```c++
#include <algorithm>
// A function to implement bubble sort
void bubbleSort( std::vector&lt; double &gt; &amp;array )
{
    for (int i = 0; i &lt; array.size()-1; i++ ) // T1 = n * T2
    {
        for ( int j = 0; j &lt; array.size()-1; j++ ) T2 = n * T3
        {
            if ( array[j] &gt; arr[j+1] ) // T3 = 1
                std::swap( array[j] , array[j+1] );
        }
    }
}
```

--
$$ T(n) = T_1 = n \times T_2 = n \times n = n^2 $$


--
$$ O(T(n)) = O(n^2) $$


---
### Selection Sort


--
<img src="/gallery/selectionsort.gif" />
&gt; credits: [GNU license](https://en.wikipedia.org/wiki/Joestape89)


---
#### Implementation


--
```c++
#include <algorithm>
void selectionSort( std::vector&lt; double &gt; &amp;array )
{
    // One by one move boundary of unsorted subarray
    for (int i = 0; i &lt; array.size() -1; i++)
    {
        // Find the minimum element in unsorted array
        int min_idx = i;

        for (int j = i+1; j &lt; array.size() ; j++)
        {
            if ( array[j] &lt; array[min_idx] )
                min_idx = j;
        }

        // Swap the found minimum element with the first element
        std::swap( array[min_idx] ,  array[i] );
    }
}
```

---
#### Complexity Analysis

```c++
#include <algorithm>
void selectionSort( std::vector&lt; double &gt; &amp;array )
{
    // One by one move boundary of unsorted subarray
    for (int i = 0; i &lt; array.size() -1; i++) // T1 = n * ( T2 + T3 + T4 )
    {
        // Find the minimum element in unsorted array
        int min_idx = i; // T2 = 1

        for (int j = i+1; j &lt; array.size() ; j++) // T3 = O(n)
        {
            if ( array[j] &lt; array[min_idx] )
                min_idx = j;
        }

        // Swap the found minimum element with the first element
        std::swap( array[min_idx] ,  array[i] ); // T4 = 1
    }
}
```

--
$$ T(n) = T_1 = n \times (T_2 + T_3 + T_4) = n \times( O(n) + 2 ) $$


--
$$ O(T(n)) = O(n^2) $$









&lt;/textarea&gt;
    
    

</algorithm></algorithm></algorithm></algorithm></iostream></textarea>


    <footer class="site-footer">


    <script src="/javascript/jquery-3.3.1.min.js" type="text/javascript"></script>
    <script src="/javascript/remark.min.js" type="text/javascript"></script>

    <script type="text/javascript">
        var hljs = remark.highlighter.engine;
    </script>
    <script src="/javascript/terminal.language.js" type="text/javascript"></script>


    <script type="text/javascript">
        var options = {
            highlightStyle: "monokai",
            highlightSpans: true,
            countIncrementalSlides: false
        };
        var slideshow = remark.create(options);

        // extract the embedded styling from ansi spans
        $('code.terminal span.hljs-ansi').replaceWith(function (i, x) {
            return x.replace(/&lt;(\/?(\w+).*?)&gt;/g, '<$1>')
        });
    </script>


    <script defer src="https://use.fontawesome.com/releases/v5.0.8/js/all.js" integrity="sha384-SlE991lGASHoBfWbelyBPLsUlwY1GwNDJo3jSJO04KZ33K2bwfV9YBauFfnzvynJ"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
        crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy"
        crossorigin="anonymous"></script>
    <div id="fb-root"></div>
    <script async defer crossorigin="anonymous" src="https://connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v3.2"></script>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

</footer>

    
</body>

</html>