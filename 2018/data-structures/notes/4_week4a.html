<!DOCTYPE html>

<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Week 4 - Part1: Struct, Stacks, Linked Lists, and Queues</title>
  <meta name="description" content="These pages contain online teaching materials prepared by teaching assistants in the biomedical engineering department at Cairo University.">

  <link rel="icon" type="image/png" href="/icon.png" />
  
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="/2018/data-structures/notes/4_week4a.html">
  <link rel="alternate" type="application/rss+xml" title="Tutorials for SBME Students" href="/feed.xml">
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/main.css">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    <!-- 
     -->
    
    
<!--   
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
            <a class="page-link" href="/2019/CG/notes/1-week1.html">Introduction to Computer Graphics</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/10_week10.html">Week 10: Merge and Quick Sorting, more on Dijkstra, and the Final Project</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/assignments/10_week10.html">Assignment 6: Wrapping All Data Structures and Algorithms in a Single Project</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/11_week11.html">Week 10: Hashes and Final Project Criteria</a>
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/notes/11_week11.html">Week 11: Revision</a>
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/notes/12_week12.html">Week 12: Introduction to Image Processing</a>
            
          
            
            
            <a class="page-link" href="/2020/cv/assignments/1_assignment1.html">Assignment 1: Images, Histograms, Gradients</a>
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/assignments/1_assignment1.html">Assignment 1: Volume rendering with VTK</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/assignments/1_assignment1.html">Assignment 1: Images, Histograms, Gradients</a>
            
          
            
            
            <a class="page-link" href="/2019/cv/assignments/1_assignment1.html">Assignment 1: Images, Histograms, Gradients</a>
            
          
            
            
            <a class="page-link" href="/2019/stl-intro/notes/1_oop1.html">Introduction to OOP</a>
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/notes/1_week1.html">Introduction to BME: Getting Started</a>
            
          
            
            
            <a class="page-link" href="/2019/microprocessor/notes/1_week1.html">ESP</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/notes/1_week1.html">Week 1: Warming up with Python Basics</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/assignments/1_week1.html">Assignment 1: Revision on C++</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/assignments/1_week1.html">Assignment 1: Revision on C++</a>
            
          
            
            
            <a class="page-link" href="/2018/dsp/notes/1_week1.html">Week 1: Signals in Python</a>
            
          
            
            
            <a class="page-link" href="/2020/cv/notes/1_week1.html">Week 1: Image Processing 1</a>
            
          
            
            
            <a class="page-link" href="/2019/cv/notes/1_week1.html">Week 1: Image Processing 1</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/1_week1a.html">Week 1 - Part 1: Basics of C++</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/notes/1_week1a.html">Week 1 - Part 1: Basics of C++</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/assignments/1_week1a.html">Assignment 1 - part 1: Your first experience with Git and our Github classroom</a>
            
          
            
            
            <a class="page-link" href="/2018/measurements/assignments/1_week1a.html">Assignment 1 - part 1: Your first experience with Git and our Github classroom</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/notes/1_week1a.html">Week 1 - Part 1: Basics of C++</a>
            
          
            
            
            <a class="page-link" href="/2018/measurements/assignments/1_week1b.html">Assignment 1 - part 2: Solving the assignment in LaTeX</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/assignments/1_week1b.html">Assignment 1 - part 2: Revision on C++</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/notes/1_week1b.html">Week 1 - Part 2: Basics of Git and Github</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/notes/1_week1b.html">Week 1 - Part 2: Basics of Git and Github</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/1_week1b.html">Week 1 - Part 2: Basics of Git and Github</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/assignments/1_week1re.html">Task 1: Resubmission</a>
            
          
            
            
            <a class="page-link" href="/2019/CG/notes/2-week2.html">Transformations</a>
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/assignments/2_assignment2.html">Assignment 2: Arduino signal acquisition</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/assignments/2_assignment2.html">Assignment 2: Spatial domain filters, Images in frequency domain</a>
            
          
            
            
            <a class="page-link" href="/2019/cv/assignments/2_assignment2.html">Assignment 2: Spatial domain filters, Images in frequency domain, and Hough Transforms</a>
            
          
            
            
            <a class="page-link" href="/2020/cv/assignments/2_assignment2.html">Assignment 2: Spatial domain filters, Images in frequency domain, and Hough Transforms</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/2_code_formatting.html">Code Styling (formatting): Enhancing Your Code Readability</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/notes/2_code_formatting.html">Code Styling (formatting): Enhancing Your Code Readability</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/notes/2_code_formatting.html">Code Styling (formatting): Enhancing Your Code Readability</a>
            
          
            
            
            <a class="page-link" href="/2019/stl-intro/notes/2_oop2.html">Introduction to OOP 2</a>
            
          
            
            
            <a class="page-link" href="/2019/cv/notes/2_week2.html">Week 2: Images in Frequency Domain</a>
            
          
            
            
            <a class="page-link" href="/2018/dsp/notes/2_week2.html">Week 2: Signals and Basis Functions: Composition and Decomposition</a>
            
          
            
            
            <a class="page-link" href="/2020/cv/notes/2_week2.html">Week 2: Images in Frequency Domain</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/notes/2_week2.html">Week 2: Image Processing 1</a>
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/notes/2_week2.html">Week 2: Medical Imaging and Visualization</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/assignments/2_week2a.html">Assignment 2: C++ Basic Operations on Memory</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/assignments/2_week2a.html">Assignment 2: C++ Basic Operations on Memory</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/assignments/2_week2a.html">Assignment 2: C++ Basic Operations on Memory</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/notes/2_week2a.html">Week 2 - Part1: Memory, pointers, and references</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/notes/2_week2a.html">Week 2 - Part1: Memory, pointers, and references</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/2_week2a.html">Week 2 - Part1: Memory, pointers, and references</a>
            
          
            
            
            <a class="page-link" href="/2019/CG/notes/3-week3.html">Projection</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/assignments/3_assignment3.html">Assignment 3: Canny, Hough transform, Harris and Fast</a>
            
          
            
            
            <a class="page-link" href="/2020/cv/assignments/3_assignment3.html">Assignment 3: Corner Detection, Image Segmentation and clustering , Snake</a>
            
          
            
            
            <a class="page-link" href="/2019/cv/assignments/3_assignment3.html">Assignment 3: Corner Detection, Image Segmentation and clustering , Snake</a>
            
          
            
            
            <a class="page-link" href="/2019/microprocessor/assignments/3_assignment3.html">Assignment 3: CNC Plotter</a>
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/assignments/3_assignment3.html">Assignment 3: Digital signal Processing</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/3_faq1.html">FAQ #1: Why exposing namespaces is a bad practice</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/3_faq2.html">FAQ #2: Why `int *p = &amp;x` != `*p = &amp;x`</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/3_faq3.html">FAQ #3: Why not using `std::cin` inside functions of particular logic</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/notes/3_week3.html">Week 3: Images in Frequency Domain</a>
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/notes/3_week3.html">Week 3: Arduino Microcontroller</a>
            
          
            
            
            <a class="page-link" href="/2018/dsp/notes/3_week3.html">Week 3: Euler&#39;s Identity, Sinusoids, and Fourier</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/assignments/3_week3.html">Assignment 3: Arrays</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/assignments/3_week3.html">Assignment 3: Arrays</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/assignments/3_week3a.html">Assignment 3 - Part 1: Arrays</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/notes/3_week3a.html">Week 3 - Part1: Static Arrays and Dynamic Arrays</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/notes/3_week3a.html">Week 3 - Part1: Static Arrays and Dynamic Arrays</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/3_week3a.html">Week 3 - Part1: Static Arrays and Dynamic Arrays</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/3_week3b.html">Week 3 - Part2: Command Line Arguments and Compilation of Multiple Files</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/notes/3_week3b.html">Week 3 - Part2: Command Line Arguments and Compilation of Multiple Files</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/assignments/3_week3b.html">Assignment 3 - Part 2: Struct and Functions Overloading</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/notes/3_week3b.html">Week 3 - Part2: Command Line Arguments and Compilation of Multiple Files</a>
            
          
            
            
            <a class="page-link" href="/2019/CG/notes/4-week4.html">Camera Transformation</a>
            
          
            
            
          
            
            
            <a class="page-link" href="/2019/microprocessor/assignments/4_assignment4.html">Assignment 4: Prosthetic Hand</a>
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/assignments/4_assignment4.html">Assignment 4: Bioinformatics</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/assignments/4_assignment4.html">Assignment 4 : Otsu thresholding, Region growing, mean shift segmentation</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/notes/4_week4.html">Week 4: Image Filtering and Edge Detection</a>
            
          
            
            
            <a class="page-link" href="/2019/microprocessor/notes/4_week4.html">Version Control System</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/assignments/4_week4.html">Assignment 3 - Part 2: Struct and Functions Overloading</a>
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/notes/4_week4.html">Week 4: Hardware</a>
            
          
            
            
            <a class="page-link" href="/2018/dsp/notes/4_week4.html">Week 3: Euler&#39;s Identity, Sinusoids, and Fourier</a>
            
          
            
            
            <a class="page-link" href="/2019/cv/notes/4_week4.html">Week 4: Hough Transform (Line and Circle Detection)</a>
            
          
            
            
            <a class="page-link" href="/2020/cv/notes/4_week4.html">Week 4: Hough Transform (Line and Circle Detection)</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/assignments/4_week4.html">Assignment 3 - Part 2: Struct and Functions Overloading</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/4_week4a.html">Week 4 - Part1: Struct, Stacks, Linked Lists, and Queues</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/notes/4_week4a.html">Week 4 - Part1: Struct, Stacks, Linked Lists, and Queues</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/notes/4_week4a.html">Week 4 - Part1: Struct, Stacks, Linked Lists, and Queues</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/assignments/4_week4a.html">Group Assignment 4 - Part 1: Git for Teams and Markdown Resumes</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/4_week4b.html">Week 4 - Part2: More on Structs, Linked Lists, Naming Conventions, Const-correctness, Build Systems, and Git for Teams</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/assignments/4_week4b.html">Assignment 4: Stacks and Queues</a>
            
          
            
            
            <a class="page-link" href="/2019/CG/notes/5-week5.html">Ray Casting &amp; Animation</a>
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/assignments/5_assignment5.html">Assignment 5: Image Processing</a>
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/notes/5_week5.html">Week 5: Introduction to DSP</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/notes/5_week5.html">Week 5: More on Structs, Linked Lists, Const-correctness</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/notes/5_week5.html">Week 5: More on Structs, Linked Lists, Const-correctness</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/notes/5_week5.html">Week 5: Hough Transform (Line and Circle Detection)</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/assignments/5_week5a.html">Assignment 4 (Groups): Git for Teams and Markdown Resumes</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/5_week5a.html">Week 5 - Part1: Recursion, Big-Oh Notation, Markdown</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/assignments/5_week5a.html">Assignment 4 (Groups): Git for Teams and Markdown Resumes</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/assignments/5_week5b.html">Assignment 5: Stacks and Queues</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/assignments/5_week5b.html">Assignment 5: Stacks and Queues</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/assignments/5_week5remake.html">Assignment 5 (individual makeup and practicing): Stacks and Queues</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/assignments/5_week5remake.html">Assignment 5 (individual makeup and practicing): Stacks and Queues</a>
            
          
            
            
            <a class="page-link" href="/2019/CG/notes/6-week6.html">Textue Mapping</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/notes/6_week6.html">Week 6: Corner Detection</a>
            
          
            
            
            <a class="page-link" href="/2020/cv/notes/6_week6.html">Week 6: Region Growing and Clustering Segmentation)</a>
            
          
            
            
            <a class="page-link" href="/2019/microprocessor/notes/6_week6.html">Overview of Raspberry Pi zero </a>
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/notes/6_week6.html">Week 6: Medical Instrumentation</a>
            
          
            
            
            <a class="page-link" href="/2019/cv/notes/6_week6.html">Week 6: Region Growing and Clustering Segmentation)</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/6_week6a.html">Week 6 - Part1: Sorting, Bubble Sort, Selection Sort, Learning Resources</a>
            
          
            
            
            <a class="page-link" href="/2019/CG/notes/7-week7.html">Medical Visualization &amp; Volume Rendering</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/assignments/7_exercises.html">Exercises 1: C++ Basics and Linear Data Structures</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/assignments/7_week7.html">Assignment 6: BST, Set, and Map</a>
            
          
            
            
            <a class="page-link" href="/2020/cv/notes/7_week7.html">Week 7: Feature Extraction, Description and, matching</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/assignments/7_week7.html">Assignment 6: BST, Set, and Map</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/notes/7_week7.html">Week 7: Segmentation (Thresholding and Region growing)</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/notes/7_week7.html">Week 7: Binary Search Trees, Sets (ADT) and Maps (ADT)</a>
            
          
            
            
            <a class="page-link" href="/2019/cv/notes/7_week7.html">Week 7: Feature Extraction, Description and, matching</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/notes/7_week7.html">Week 7: Binary Search Trees, Sets (ADT) and Maps (ADT)</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/7_week7a.html">Week 7 - Part1: Revision, Common Mistakes, and Best Practices, Type normalization using C++ templates</a>
            
          
            
            
            <a class="page-link" href="/2020/cv/notes/8_week8.html">Week 8: Principle component analysis(PCA) and face recognition with PCA</a>
            
          
            
            
            <a class="page-link" href="/2019/cv/notes/8_week8.html">Week 8: Principle component analysis(PCA) and face recognition with PCA</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/notes/8_week8.html">Week 8: Heaps, Priority Queues (ADT), and Shortest Path Problem</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/notes/8_week8.html">Week 8: Segmentation (Clustering Segmentation)</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/notes/8_week8.html">Week 8: Heaps, Priority Queues (ADT), and Shortest Path Problem</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/8_week8a.html">Week 8 - Part1: Binary Search Trees, Sets (ADT) and Maps (ADT)</a>
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/notes/9_week9.html">Week 9 &amp; 10: Introduction to Bioinformatics</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/notes/9_week9.html">Week 9: Hash tables</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/notes/9_week9.html">Week 9: Heaps, Priority Queues (ADT), and Shortest Path Problem</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/notes/9_week9.html">Week 10: Image features, feature descriptors, and feature matching</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/notes/9_week9.html">Week 9: Hash tables</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/notes/9_week9b.html">Week 10: Exercises</a>
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
            <a class="page-link" href="/about/">About</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/assignments/resumes/asem.html">Resume</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/assignments/resumes/asem.html">Resume</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/assignments/resumes/asem.html">Resume</a>
            
          
            
            
            <a class="page-link" href="/2019/CG/assignments/assignment1.html">Assignment 1: Robotic Arm</a>
            
          
            
            
            <a class="page-link" href="/2019/CG/assignments/assignment2.html">Assignment 2: Full Body</a>
            
          
            
            
            <a class="page-link" href="/2019/CG/assignments/assignment3.html">Assignment 3: Body Animation</a>
            
          
            
            
            <a class="page-link" href="/2019/CG/assignments/assignment4.html">Assignment 4: Volume Rendering (VTK)</a>
            
          
            
            
          
            
            
            <a class="page-link" href="/2019/data-structures/notes/cmake.html">Introduction to CMake</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/notes/cmake.html">Introduction to CMake</a>
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
            <a class="page-link" href="/2019/data-structures/presentations/4_week4/">Week 4 - Part1: Struct, Stacks, Linked Lists, and Queues</a>
            
          
            
            
            <a class="page-link" href="/2020/cv/presentations/2_week2/">Week 3: Images in Frequency Domain</a>
            
          
            
            
            <a class="page-link" href="/2020/cv/presentations/1_week1/">Week 1: Introduction to Python and Images</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/presentations/5_week5/">Week 5: More on Structs, Linked Lists, Const-correctness</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/presentations/7_week7/">Week 7: Binary Search Trees, Sets (ADT) and Maps (ADT)</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/presentations/9_week9/">Week 9: hash tables</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/presentations/2_week2/">Week2: Memory, pointers, and references</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/presentations/6_week6/">Week 6: Recursion, Big-Oh Notation, Queue Applications</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/presentations/10_week10/">Week 10: Sorting (2)</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/presentations/1_week1/">Week1: Introduction to &#39;Introduction to Data Structures and Algorithms (SBE201)&#39;</a>
            
          
            
            
            <a class="page-link" href="/2020/cv/presentations/3_week3/">Week 4: Image Filtering and Edge Detection</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/presentations/4_week4a/">Week 4: Struct, Stacks, Linked Lists, and Queues</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/presentations/8_week8/">Week 8: Heaps, Priority Queues (ADT), and Shortest Path Problem</a>
            
          
            
            
            <a class="page-link" href="/2020/cv/presentations/5_week5/">Week 5: Corner Detection, Laplacian, and Revision Problems</a>
            
          
            
            
            <a class="page-link" href="/2020/cv/presentations/8_week8/">Week 8: Object detection, verification, and recognition</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/presentations/5_week5/">Week 5: More on Structs, Linked Lists, Const-correctness</a>
            
          
            
            
            <a class="page-link" href="/2019/Database/presentations/1_week1/">Week1: Introduction to &#39;Computer Systems (Database) (SBE306)&#39;</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/presentations/7_week7/">Week 7: Binary Search Trees, Sets (ADT) and Maps (ADT)</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/presentations/9_week9/">Week 9: hash tables</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/presentations/2_week2/">Week2: Memory, pointers, and references</a>
            
          
            
            
            <a class="page-link" href="/2019/stl-intro/presentations/1_oop1/">Introduction to OOP 1</a>
            
          
            
            
            <a class="page-link" href="/2019/stl-intro/presentations/3_stl_misc/">Introduction to the STL</a>
            
          
            
            
            <a class="page-link" href="/2019/stl-intro/presentations/2_oop2/">Introduction to OOP 2</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/presentations/6_week6/">Week 6: Recursion, Big-Oh Notation, Queue Applications</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/presentations/10_week10/">Week 10: Sorting (2)</a>
            
          
            
            
            <a class="page-link" href="/2019/CG/presentations/8_week8/">Week 8: Visualization Toolkit (VTK)</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/presentations/3_week3/">Week 3: Arrays, Command Line Arguments, and Libraries</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/presentations/4_week4a/">Week 4: Struct, Stacks, Linked Lists, and Queues</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/presentations/8_week8/">Week 8: Heaps, Priority Queues (ADT), and Shortest Path Problem</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/presentations/4_week4/">Week 4 - Part1: Struct, Stacks, Linked Lists, and Queues</a>
            
          
            
            
            <a class="page-link" href="/2019/cv/presentations/8_week8/">Week 8: Object detection, verification, and recognition</a>
            
          
            
            
            <a class="page-link" href="/2019/cv/presentations/3_week3/">Week 4: Image Filtering and Edge Detection</a>
            
          
            
            
            <a class="page-link" href="/2019/cv/presentations/1_week1/">Week 1: Introduction to Python and Images</a>
            
          
            
            
            <a class="page-link" href="/2019/cv/presentations/2_week2/">Week 3: Images in Frequency Domain</a>
            
          
            
            
            <a class="page-link" href="/2019/cv/presentations/5_week5/">Week 5: Corner Detection, Laplacian, and Revision Problems</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/presentations/3_week3/">Week 3: Arrays, Command Line Arguments, and Libraries</a>
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
          
            
            
            <a class="page-link" href="/2018/measurements/notes/overleaf-github.html">Integrating Overleaf to Your Github Repository</a>
            
          
            
            
            <a class="page-link" href="/2019/Database/project/project.html">SBE306: Project</a>
            
          
            
            
            <a class="page-link" href="/2018/cv/assignments/project.html">Course Project</a>
            
          
            
            
            <a class="page-link" href="/2018/data-structures/project.html">Final Project Results</a>
            
          
            
            
            <a class="page-link" href="/2020/data-structures/notes/public_key.html">Steps for using Public Key Authentication for accessing your GitHub repositories</a>
            
          
            
            
            <a class="page-link" href="/2019/data-structures/notes/public_key.html">Steps for using Public Key Authentication for accessing your GitHub repositories</a>
            
          
            
            
            <a class="page-link" href="/2018/measurements/assignments/python-lab.html">Python lab</a>
            
          
            
            
          
            
            
          
            
            
            <a class="page-link" href="/2019/intro-to-BME/notes/section.html">Title</a>
            
          
            
            
          
            
            
            <a class="page-link" href="/2020/data-structures/presentations/week_01.html">Week1: Introduction to &#39;Introduction to Data Structures and Algorithms (SBE201)&#39;</a>
            
          
            
            
          
        </div>
      </nav>
     -->
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Week 4 - Part1: Struct, Stacks, Linked Lists, and Queues</h1>
  </header>

  <div class="post-content">
    <ul id="markdown-toc">
  <li><a href="#before-starting-stack-as-data-structure--stack-memory" id="markdown-toc-before-starting-stack-as-data-structure--stack-memory">Before starting: Stack as Data Structure != Stack Memory</a></li>
  <li><a href="#c-struct" id="markdown-toc-c-struct">C++ Struct</a></li>
  <li><a href="#functions-overloading" id="markdown-toc-functions-overloading">Functions overloading</a></li>
  <li><a href="#stacks" id="markdown-toc-stacks">Stacks</a>    <ul>
      <li><a href="#home-demo" id="markdown-toc-home-demo">Home Demo</a></li>
      <li><a href="#more-intuition-about-stack-as-adt" id="markdown-toc-more-intuition-about-stack-as-adt">More intuition about Stack as ADT</a></li>
      <li><a href="#implementing-a-stack-using-static-array" id="markdown-toc-implementing-a-stack-using-static-array">Implementing a Stack using Static Array</a>        <ul>
          <li><a href="#1-the-static-array" id="markdown-toc-1-the-static-array">1. The static array</a></li>
          <li><a href="#finally-lets-add-a-variable-indicating-the-top-element" id="markdown-toc-finally-lets-add-a-variable-indicating-the-top-element">Finally, let’s add a variable indicating the top element</a></li>
          <li><a href="#push" id="markdown-toc-push">Push</a></li>
          <li><a href="#pop" id="markdown-toc-pop">Pop</a></li>
          <li><a href="#retrieving-the-size-of-stack" id="markdown-toc-retrieving-the-size-of-stack">Retrieving the size of stack</a></li>
          <li><a href="#asking-our-stack-if-it-is-empty" id="markdown-toc-asking-our-stack-if-it-is-empty">Asking our stack if it is empty</a></li>
          <li><a href="#final-code" id="markdown-toc-final-code">Final Code</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#linked-lists" id="markdown-toc-linked-lists">Linked Lists</a>    <ul>
      <li><a href="#why-linked-lists" id="markdown-toc-why-linked-lists">Why linked lists</a></li>
      <li><a href="#the-memory-mode-array-vs-linked-list" id="markdown-toc-the-memory-mode-array-vs-linked-list">The Memory Mode: Array vs. Linked List</a></li>
      <li><a href="#pointers-revisited" id="markdown-toc-pointers-revisited">Pointers revisited</a>        <ul>
          <li><a href="#the-last-node-back" id="markdown-toc-the-last-node-back">The last Node (back)</a></li>
        </ul>
      </li>
      <li><a href="#the-ll-structure" id="markdown-toc-the-ll-structure">The LL Structure</a></li>
      <li><a href="#head-front" id="markdown-toc-head-front">Head (front)</a></li>
      <li><a href="#tail-back" id="markdown-toc-tail-back">Tail (back)</a></li>
    </ul>
  </li>
  <li><a href="#queues" id="markdown-toc-queues">Queues</a>    <ul>
      <li><a href="#home-demo-1" id="markdown-toc-home-demo-1">Home Demo</a></li>
      <li><a href="#more-intuition-about-queue-as-adt" id="markdown-toc-more-intuition-about-queue-as-adt">More intuition about Queue as ADT</a></li>
      <li><a href="#biomedical-application-queues-of-biological-signals" id="markdown-toc-biomedical-application-queues-of-biological-signals"><strong>Biomedical Application</strong>: Queues of Biological Signals</a></li>
      <li><a href="#implementing-queue-using-ll" id="markdown-toc-implementing-queue-using-ll">Implementing Queue using LL</a></li>
      <li><a href="#implementing-queue-using-concrete-array" id="markdown-toc-implementing-queue-using-concrete-array">Implementing Queue using concrete array</a>        <ul>
          <li><a href="#1-the-circular-buffer" id="markdown-toc-1-the-circular-buffer">1. The circular buffer</a></li>
          <li><a href="#finally-lets-make-two-variables-indicating-the-front-and-the-back-of-our-queue" id="markdown-toc-finally-lets-make-two-variables-indicating-the-front-and-the-back-of-our-queue">Finally, let’s make two variables indicating the front and the back of our Queue</a></li>
          <li><a href="#making-our-buffer-to-act-as-a-circular-buffer" id="markdown-toc-making-our-buffer-to-act-as-a-circular-buffer">Making our buffer to act as a circular buffer</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="before-starting-stack-as-data-structure--stack-memory">Before starting: Stack as Data Structure != Stack Memory</h2>

<p>Stack as a data structure is not related to the <strong>stack memory</strong> area we learned about last weeks, and they are completely different things. So just refer to <em>stack as a data structure</em> by <strong>Stack</strong>, and the stack memory area by <strong>Stack memory</strong>. Make yourself a glossary on your notebook.</p>

<h2 id="c-struct">C++ Struct</h2>

<p>In first week, we have walked through different primitive data types (PDTs), or the first-class citizens in the C++. However, we can make our own types, that consists of multiple members, using <code class="highlighter-rouge">struct</code> feature. <em>Members</em> in <code class="highlighter-rouge">struct</code> can either be primitive data types (PDT) or other <code class="highlighter-rouge">struct</code>s. Let’s recall our example of <code class="highlighter-rouge">rectangle::area</code> function.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">rectangle</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">area</span><span class="p">(</span> <span class="kt">double</span> <span class="n">w</span> <span class="p">,</span> <span class="kt">double</span> <span class="n">h</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We could have made a <em>custom</em> type using <code class="highlighter-rouge">struct</code>, using the following syntax.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Rectangle</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">w</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">h</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Rectangle</code> is now a custom type, consists of two <code class="highlighter-rouge">double</code>s. Think of it as a package.
We can now make our <code class="highlighter-rouge">rectangle::area</code> function more simpler, or much readable using the following implementation.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span><span class="k">namespace</span> <span class="n">rectangle</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">Rectangle</span>
    <span class="p">{</span>
        <span class="kt">double</span> <span class="n">w</span><span class="p">;</span> <span class="c1">// First member</span>
        <span class="kt">double</span> <span class="n">h</span><span class="p">;</span> <span class="c1">// Second member</span>
    <span class="p">};</span> <span class="c1">// Don't forget a semicolon here!</span>

    <span class="c1">// Now this function is more readable. The input type explains itself.</span>
    <span class="kt">double</span> <span class="n">area</span><span class="p">(</span> <span class="n">Rectangle</span> <span class="n">rectangle</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">rectangle</span><span class="p">.</span><span class="n">w</span> <span class="o">*</span> <span class="n">rectangle</span><span class="p">.</span><span class="n">h</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// If we have a pointer to Rectangle instead of a name for Rectangle</span>
    <span class="c1">// then we will access its members using the "-&gt;" arrow operator</span>
    <span class="kt">double</span> <span class="n">area2</span><span class="p">(</span> <span class="n">Rectanle</span> <span class="o">*</span><span class="n">pRect</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">pRect</span><span class="o">-&gt;</span><span class="n">w</span> <span class="o">*</span> <span class="n">pRect</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">rectangle</span><span class="o">::</span><span class="n">Rectangle</span> <span class="n">rect</span><span class="p">{</span> <span class="mi">3</span> <span class="p">,</span> <span class="mi">5</span> <span class="p">};</span> <span class="c1">// declaration+initialization of Rectangle type!</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">rectangle</span><span class="o">::</span><span class="n">area</span><span class="p">(</span> <span class="n">rect</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">rectangle</span><span class="o">::</span><span class="n">area2</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">rect</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We may also package an array (either static or dynamic) with its size, using <code class="highlighter-rouge">struct</code></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">struct</span> <span class="n">IntegerArray</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">sumArray1</span><span class="p">(</span> <span class="kt">int</span> <span class="o">*</span><span class="n">base</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">size</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sumArray2</span><span class="p">(</span> <span class="n">IntegerArray</span> <span class="n">array</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="p">.</span><span class="n">size</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">array</span><span class="p">.</span><span class="n">base</span><span class="p">[</span> <span class="n">i</span> <span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>

    <span class="c1">// DRY solution ==&gt; return sumArray1( array.base , array.size );</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="n">IntegerArray</span> <span class="n">array</span><span class="p">{</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="mi">10</span> <span class="p">};</span> <span class="c1">// Initializes base and size members.</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sumArray1</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="mi">10</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sumArray2</span><span class="p">(</span> <span class="n">array</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="c1">// We still need to delete the array on the heap</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">array</span><span class="p">.</span><span class="n">base</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can also use <code class="highlighter-rouge">struct</code> to <strong>return multiple values</strong>, which is more safe and clean than using multiple references as input and mofifying our interesting results into these input references.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">struct</span> <span class="n">ECGArray</span> <span class="c1">// We could name it also DoubleArray</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="o">*</span><span class="n">samples</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Statistics</span>
<span class="p">{</span>
    <span class="c1">// Members can have default values after declaration of Statistic type variable.</span>
    <span class="c1">// So you don't need to explicitly to initialize them from outside.</span>
    <span class="kt">double</span> <span class="n">mean</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="kt">double</span> <span class="n">variance</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="kt">double</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Very self-explaining function header!</span>
<span class="n">Statistics</span> <span class="nf">analyzeECG</span><span class="p">(</span> <span class="n">ECGArray</span> <span class="n">ecg</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">Statistics</span> <span class="n">analysis</span><span class="p">;</span> <span class="c1">// Declaration, and no need for explicit initialization now</span>

    <span class="n">analysis</span><span class="p">.</span><span class="n">mean</span> <span class="o">=</span> <span class="c1">// Some logic here</span>
    <span class="n">analysis</span><span class="p">.</span><span class="n">variance</span> <span class="o">=</span> <span class="c1">// Some logic there</span>
    <span class="c1">// And so on.</span>

    <span class="k">return</span> <span class="n">analysis</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="functions-overloading">Functions overloading</h2>

<p>C++ allows you to have functions with same name, <strong>but</strong> different parameters.</p>

<p>For example, this is <strong>not allowed</strong> in C++:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">area</span><span class="p">(</span> <span class="kt">double</span> <span class="n">w</span> <span class="p">,</span> <span class="kt">double</span> <span class="n">h</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">area</span><span class="p">(</span> <span class="kt">double</span> <span class="n">base</span> <span class="p">,</span> <span class="kt">double</span> <span class="n">height</span> <span class="p">)</span> <span class="c1">// Compiler Error</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">base</span> <span class="o">*</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It becomes <strong>ambiguous</strong> now to call <code class="highlighter-rouge">area(1.4,5)</code>, which <code class="highlighter-rouge">area</code> function should be called?</p>

<p>However, it is supported by C++ to have functions with same name, but different parameters (different types or different number of parameters).</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Rectangle</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">w</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">h</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">area</span><span class="p">(</span> <span class="kt">double</span> <span class="n">d</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">d</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// square area</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">area</span><span class="p">(</span> <span class="kt">double</span> <span class="n">w</span><span class="p">,</span> <span class="kt">double</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">area</span><span class="p">(</span> <span class="n">Rectangle</span> <span class="n">rect</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">rect</span><span class="p">.</span><span class="n">w</span> <span class="o">*</span> <span class="n">rect</span><span class="p">.</span><span class="n">h</span><span class="p">;</span>
    <span class="c1">// DRY solution ==&gt; return area( rect.w , rect.h );</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="stacks">Stacks</h2>

<p>In fact, <strong>Stack</strong> is more of <em>behaviour</em> of structure than being a structure itself. We can turn a regular array (either static or dynamic) into a <strong>stack</strong> with simple modification. <strong>Stack</strong> is an Abstract Data Type (ADT) they may have different implementations:</p>

<ul>
  <li>Using arrays.</li>
  <li>Using linked lists (later on this note).</li>
</ul>

<p>For both implementations, the following requirements should be satisfied in order to hava an ADT <strong>Stack</strong> (from <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">wikipedia</a>):</p>

<ul>
  <li><strong>push</strong>, which adds an element to the collection, and.</li>
  <li><strong>pop</strong>, which removes the most recently added element that was not yet removed.</li>
</ul>

<p><em>The order in which elements come off a stack gives rise to its alternative name, <strong>LIFO</strong> (last in, first out). Additionally, a <strong>peek</strong> operation may give access to the top without modifying the stack.</em> – <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Stack (Abstract Data Type)</a>.</p>

<p><img src="/gallery/Lifo_stack.png" style="width:400" /></p>

<p>This table should draw the boundaries between <strong>Abstract Data Types (ADT)</strong> and <strong>Concrete Data Types</strong>, and keep in mind that <strong>Abstract Data Types</strong> are built upon <strong>Concrete Data Types</strong>.</p>

<table>
  <thead>
    <tr>
      <th>Abstract Data Type (ADT)</th>
      <th>Possible Implementations</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Stack</td>
      <td>Array or Linked List</td>
    </tr>
    <tr>
      <td>Queue</td>
      <td>Array or Linked List</td>
    </tr>
  </tbody>
</table>

<p>So again, we can turn an array into a <strong>Stack</strong> using minor modifications.</p>

<h3 id="home-demo">Home Demo</h3>

<p>Open <a href="https://www.cs.usfca.edu/~galles/visualization/StackArray.html">StackArray</a> and play with the stack to realize its behaviour. This demo shows a <strong>Stack</strong> implemented with <strong>arrays</strong>.</p>

<h3 id="more-intuition-about-stack-as-adt">More intuition about Stack as ADT</h3>

<p>This video should give you an intuition about <strong>Stack</strong> as an asbtract data type (ADT).</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/XSdXSmwb550" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""></iframe>

<h3 id="implementing-a-stack-using-static-array">Implementing a Stack using Static Array</h3>

<p>As we learned earlier in this page, we have an awesome feature in C++ called <code class="highlighter-rouge">struct</code>. We can make all the stack important variable in one box. So, this box should include.</p>

<h4 id="1-the-static-array">1. The static array</h4>

<p>We need to make an array with a relatively large capacity for our stack. Let’s make a static array in our box with size <strong>100</strong>. Size <strong>100</strong> is the size of the static array, which is the maximum size our <strong>Stack</strong> can have. However, initially, our <strong>Stack</strong> is empty.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Let's make a new type for our stack with a name indicating its properties:</span>
<span class="c1">// 1. Our element types are integers.</span>
<span class="c1">// 2. The ADT is Stack</span>
<span class="c1">// 3. Maximum size is 100</span>
<span class="k">struct</span> <span class="n">IntegerStack100</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">buffer</span><span class="p">[</span> <span class="mi">100</span> <span class="p">];</span>
    <span class="kt">int</span> <span class="n">capacity</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="finally-lets-add-a-variable-indicating-the-top-element">Finally, let’s add a variable indicating the top element</h4>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">IntegerStack100</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">buffer</span><span class="p">[</span> <span class="mi">100</span> <span class="p">];</span>
    <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="c1">// Default value of top is -1 when declaring the stack.</span>
    <span class="c1">// -1 means our stack is empty</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Now we have all what we need for a stack. Let’s now implement our operations</p>

<h4 id="push">Push</h4>

<p>When pushing a new element, we will increment the <em>top</em> variable, and add the new value to the array at <em>top</em> position.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">IntegerStack100</span> <span class="nf">push</span><span class="p">(</span> <span class="n">IntegerStack100</span> <span class="n">stack</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">newElement</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">++</span><span class="n">stack</span><span class="p">.</span><span class="n">top</span><span class="p">;</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span> <span class="n">stack</span><span class="p">.</span><span class="n">top</span> <span class="p">]</span> <span class="o">=</span> <span class="n">newElement</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">stack</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that we need to return the updated <code class="highlighter-rouge">IntegerStack100</code> <strong>because we have modified a copy</strong>, not the original object.</p>

<p>Alternatively, we can pass the <code class="highlighter-rouge">IntegerStack100</code> <strong>by reference</strong>, so no need for returning the updated stack, we already modified the original stack using a reference.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span> <span class="n">IntegerStack100</span> <span class="o">&amp;</span><span class="n">stack</span> <span class="p">,</span> <span class="kt">int</span> <span class="n">newElement</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">++</span><span class="n">stack</span><span class="p">.</span><span class="n">top</span><span class="p">;</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span> <span class="n">stack</span><span class="p">.</span><span class="n">top</span> <span class="p">]</span> <span class="o">=</span> <span class="n">newElement</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="pop">Pop</h4>

<p><strong>Pop</strong> operation has to remove the top element, and return in back.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pop</span><span class="p">(</span> <span class="n">IntegerStack100</span> <span class="o">&amp;</span><span class="n">stack</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">lifo</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span> <span class="n">stack</span><span class="p">.</span><span class="n">top</span> <span class="p">];</span>
    <span class="o">--</span><span class="n">stack</span><span class="p">.</span><span class="n">top</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">lifo</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="retrieving-the-size-of-stack">Retrieving the size of stack</h4>

<p>It is important to have an operation that returns the size of stack (its elements count).</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">size</span><span class="p">(</span> <span class="n">IntegerStack100</span> <span class="o">&amp;</span><span class="n">stack</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">stack</span><span class="p">.</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span> <span class="c1">// simple</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="asking-our-stack-if-it-is-empty">Asking our stack if it is empty</h4>

<p>We also need to a function to ask our stack if it is empty or not.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">isEmptyStack</span><span class="p">(</span> <span class="n">IntegerStack100</span> <span class="o">&amp;</span><span class="n">stack</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">stack</span><span class="p">.</span><span class="n">top</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Wouldn’t be much simpler to say:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">isEmptyStack</span><span class="p">(</span> <span class="n">IntegerStack100</span> <span class="o">&amp;</span><span class="n">stack</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">stack</span><span class="p">.</span><span class="n">top</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="final-code">Final Code</h4>

<p>Here is a final code, but with using <code class="highlighter-rouge">char</code> as element type.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">CharStack1000</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span> <span class="mi">1000</span> <span class="p">];</span>
    <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="c1">// Default value of top is -1 when declaring the stack.</span>
    <span class="c1">// -1 means our stack is empty</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span> <span class="n">CharStack1000</span> <span class="o">&amp;</span><span class="n">stack</span> <span class="p">,</span> <span class="kt">char</span> <span class="n">newElement</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">++</span><span class="n">stack</span><span class="p">.</span><span class="n">top</span><span class="p">;</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span> <span class="n">stack</span><span class="p">.</span><span class="n">top</span> <span class="p">]</span> <span class="o">=</span> <span class="n">newElement</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="nf">pop</span><span class="p">(</span> <span class="n">CharStack1000</span> <span class="o">&amp;</span><span class="n">stack</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">lifo</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">buffer</span><span class="p">[</span> <span class="n">stack</span><span class="p">.</span><span class="n">top</span> <span class="p">];</span>
    <span class="o">--</span><span class="n">stack</span><span class="p">.</span><span class="n">top</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">lifo</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">size</span><span class="p">(</span> <span class="n">CharStack1000</span> <span class="o">&amp;</span><span class="n">stack</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">stack</span><span class="p">.</span><span class="n">top</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span> <span class="c1">// simple</span>
<span class="p">}</span>


<span class="kt">bool</span> <span class="nf">isEmptyStack</span><span class="p">(</span> <span class="n">CharStack1000</span> <span class="o">&amp;</span><span class="n">stack</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">stack</span><span class="p">.</span><span class="n">top</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Practice yourself, and make other <strong>Stack</strong> versions of <code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">double</code>, and <code class="highlighter-rouge">bool</code>. Also, make other variants of your <strong>Stack</strong> that works with dynamic arrays. In this case, the <code class="highlighter-rouge">struct</code> should hold <em>pointer</em> to the first element of the array.</p>

<h2 id="linked-lists">Linked Lists</h2>

<p><strong>Arrays</strong> as we learned are allocated as contiguous elements in the memory (i.e a single block). In contrast, we may have our elements to be sparse in memory, but each element can see the <em>next</em> element. This kind of structure is called <strong>Linked List</strong>.</p>

<h3 id="why-linked-lists">Why linked lists</h3>

<p>Linked lists are very flexible in size. Our <strong>Arrays</strong> once constructed we cannot change their sizes, but we create a new array with new size, then copy the old elements into the new array. Which is computatinally expensive task. In linked lists, we are free to add new elements very directly.</p>

<h3 id="the-memory-mode-array-vs-linked-list">The Memory Mode: Array vs. Linked List</h3>

<p><img src="/gallery/dna_array.svg" style="width:400" /></p>

<p><img src="/gallery/dna_ll.svg" style="width:400" /></p>

<h3 id="pointers-revisited">Pointers revisited</h3>

<p>Each element in the linked list is denoted by a <em>Node</em>. To connect between nodes, we may use <strong>pointers</strong>. So, each <em>Node</em> has a <strong>pointer</strong> pointing to the <em>Next Node</em>.
The <strong>DNA</strong> sequence as a Linked List (LL), can be achieved with the following</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p><img src="/gallery/dna_ll_annotated.svg" style="width:400" /></p>

<h4 id="the-last-node-back">The last Node (back)</h4>

<p>How to recognize that we are on the latest <em>Node</em>?. In this case, we will make the <strong>next</strong> pointer equals to <code class="highlighter-rouge">nullptr</code>. So we know then we are reached the last element.</p>

<p>For example, if we need to print all elements on a list, we will use this very simple logic:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printLL</span><span class="p">(</span> <span class="n">Node</span><span class="o">*</span> <span class="n">front</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">front</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span> <span class="n">current</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="the-ll-structure">The LL Structure</h3>

<p>We need to make a <code class="highlighter-rouge">struct</code> that will define our <strong>LL</strong>.</p>

<h3 id="head-front">Head (front)</h3>

<p>If we have a <strong>pointer</strong> pointing to the first element in our <strong>LL</strong>, then we have an access to the whole list, because every <em>Node</em> can see the <em>Next Node</em>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">CharLinkedList</span>
<span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="tail-back">Tail (back)</h3>

<p><em>Tail</em> is a <strong>pointer</strong> pointing to the last element to the list. So when we add a new element in the list, we are going to use the <em>tail</em> pointer.</p>

<p>So our <strong>LL</strong> <code class="highlighter-rouge">struct</code> is now consisting of:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">CharLinkedList</span>
<span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we need to <em>insert</em> element on the back:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">insertToList</span><span class="p">(</span> <span class="n">CharLinkedList</span> <span class="o">&amp;</span><span class="n">list</span> <span class="p">,</span> <span class="kt">char</span> <span class="n">newElement</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">list</span><span class="p">.</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">{</span> <span class="n">newElement</span> <span class="p">,</span> <span class="nb">nullptr</span> <span class="p">};</span>
    <span class="n">list</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we only have an access to the <strong>head</strong> of the <strong>LL</strong>, or in other words, if we don’t have a <strong>tail</strong>, and need to insert an element to the back, then we have to start iterating from the front until we reach the last element in the <strong>LL</strong>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">insertToList</span><span class="p">(</span> <span class="n">CharLinkedList</span> <span class="o">&amp;</span><span class="n">list</span> <span class="p">,</span> <span class="kt">char</span> <span class="n">newElement</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
    
    <span class="k">if</span><span class="p">(</span> <span class="n">current</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">{</span> <span class="n">newElement</span> <span class="p">,</span> <span class="nb">nullptr</span> <span class="p">};</span>
        <span class="n">list</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">while</span><span class="p">(</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">{</span> <span class="n">newElement</span> <span class="p">,</span> <span class="nb">nullptr</span> <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<iframe allowfullscreen="" src="http://www.algomation.com/embeddedplayer?embedded=true&amp;algorithm=58a0cb534833c1040095d576" width="900" height="556" seamless="seamless" frameborder="0" style="border:1px solid lightgray" scrolling="no"></iframe>

<h2 id="queues">Queues</h2>

<p><strong>Queues</strong> are another Abstract Data Type (ADT), that might be implemented using concrete structures like arrays and linked lists. We refer to <strong>Queue</strong> behaviour by <strong>FIFO</strong> (first in, first out).</p>

<p>The ADT <strong>Queue</strong> should satisfy the following requirements (from <a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">wikipedia</a>):</p>

<ul>
  <li><strong>enqueue</strong>, which adds an element to the collection end (back), and.</li>
  <li><strong>dequeue</strong>, which removes the first element added (front) that was not yet removed.</li>
</ul>

<p><em>This makes the queue a First-In-First-Out (FIFO) data structure. In a FIFO data structure, the first element added to the queue will be the first one to be removed. Additionally, a <strong>peek</strong> operation may give access to the front element without dequeuing it.</em> – <a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">Queue (Abstract Data Type)</a></p>

<p><img src="/gallery/Data_Queue.svg" style="width:400" /></p>

<h3 id="home-demo-1">Home Demo</h3>

<p>Open <a href="https://www.cs.usfca.edu/~galles/visualization/QueueArray.html">QueueArray</a> and play with the queue to realize its behaviour. This demo shows a <strong>Queue</strong> implemented with <strong>arrays</strong>.</p>

<h3 id="more-intuition-about-queue-as-adt">More intuition about Queue as ADT</h3>

<p>To get more inuition about <strong>Queue</strong> properties as an ADT:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/PjQdvpWfCmE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen=""></iframe>

<h3 id="biomedical-application-queues-of-biological-signals"><strong>Biomedical Application</strong>: Queues of Biological Signals</h3>

<p><strong>Queues</strong> as a data structure can be used to represent a time window (interval) of biological signal being displayed on screen.</p>

<p><img src="/gallery/biosignal.gif" style="width:400" /></p>

<p>For example, every <strong>10 ms</strong> a <strong>Queue</strong> of <strong>ECG</strong> signal may <em>enqueue</em> new sample to the back (right to the figure), and <em>dequeue</em> old sample from the front (left to the figure). So, this way you can view an <strong>ECG</strong> signal of the last <strong>30 seconds</strong>. Therefore, we are interested to have a <strong>queue</strong> with capacity of:</p>

<script type="math/tex; mode=display">\text{Queue (window) size} = \frac{30}{10^{-3}} = 3000  \text{ sample}</script>

<h3 id="implementing-queue-using-ll">Implementing Queue using LL</h3>

<p>Soon.</p>

<h3 id="implementing-queue-using-concrete-array">Implementing Queue using concrete array</h3>

<h4 id="1-the-circular-buffer">1. The circular buffer</h4>

<p>We need to make a buffer (array) with a relatively large capacity for our queue. Let’s make a static array in our box with size <strong>100</strong>. Size <strong>100</strong> is the size of the static array, which is the maximum size our <strong>Queue</strong> can have. Similarly, our <strong>Queue</strong> is initially empty.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Let's make a new type for our Queue with a name indicating its properties:</span>
<span class="c1">// 1. Our element types are integers.</span>
<span class="c1">// 2. The ADT is Stack</span>
<span class="c1">// 3. Maximum size is 100</span>
<span class="k">struct</span> <span class="n">DoubleQueue100</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">buffer</span><span class="p">[</span> <span class="mi">100</span> <span class="p">];</span>
    <span class="kt">int</span> <span class="n">capacity</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="finally-lets-make-two-variables-indicating-the-front-and-the-back-of-our-queue">Finally, let’s make two variables indicating the front and the back of our Queue</h4>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">DoubleQueue</span><span class="p">{</span>
    <span class="kt">double</span> <span class="n">buffer</span><span class="p">[</span> <span class="mi">100</span> <span class="p">];</span>
    <span class="kt">int</span> <span class="n">capacity</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">front</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">back</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="making-our-buffer-to-act-as-a-circular-buffer">Making our buffer to act as a circular buffer</h4>

<p>We need to make our buffer to be flexible such that we don’t need to shift all elements when we <em>dequeue</em> the front element. Alternatively, we will trun our buffer to a circular buffer using simple logic.</p>

<p><img src="/gallery/circular-buffer-animation.gif" style="width:400" /></p>

<ul>
  <li>the <strong>blue pointer</strong> is the front, where we <em>dequeue</em> elements.</li>
  <li>the <strong>red pointer</strong> is the back, where we <em>enqueue</em> new elements.</li>
</ul>

  </div>

</article>

<!-- 
Thanks to Roman Cheplyaka for his instructions to minifying the mathjax package:
https://ro-che.info/articles/2017-04-02-deploying-mathjax 
-->

<script src="/mathjax/MathJax.js"></script>

<script type="text/javascript">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    tex2jax: { inlineMath: [['$', '$'], ['\\(', '\\)']], skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] },
    jax: ["input/TeX", "output/HTML-CSS"],
    "HTML-CSS": {
      availableFonts: ["TeX"],
      imageFont: null
    },
    MathMenu: {
      showRenderer: false,
      showFontMenu: false,
      showLocale: false
    }
  });
</script>
      </div>
    </main>

    <footer class="site-footer">
  <div class="wrapper">

    <!-- <h2 class="footer-heading">Tutorials for SBME Students</h2> -->

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-3">
        <h4>About</h4>
        <p>These pages contain online teaching materials prepared by teaching assistants in the biomedical engineering department at Cairo University.</p>
      </div>

      <div class="footer-col footer-col-2">
      </div>
      
      <div class="footer-col footer-col-1">
        <h4>Correspondence</h4>
        <ul class="contact-list">
          <li>Asem Alaa 
            <a href="https://a-alaa.github.io"><i class="fas fa-home"></i></a>
          </li>
          <li>Eslam Adel 
            <a href="mailto:eslam.a.mahmoud@eng1.cu.edu.eg"><i class="fas fa-envelope"></i></a>
            <a href="https://github.com/EslamAdel"><i class="fab fa-github"></i></a>
          </li>
          <li>Ayman Anwar 
            <a href="mailto:ayman.m.anwar@eng1.cu.edu.eg"><i class="fas fa-envelope"></i></a>
            <a href="https://github.com/A-M-Anwar"><i class="fab fa-github"></i></a>
          </li>
        </ul>
      </div>

     


    </div>

  </div>

  <script defer src="https://use.fontawesome.com/releases/v5.0.8/js/all.js" integrity="sha384-SlE991lGASHoBfWbelyBPLsUlwY1GwNDJo3jSJO04KZ33K2bwfV9YBauFfnzvynJ"
    crossorigin="anonymous"></script>
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
    crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
    crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy"
    crossorigin="anonymous"></script>
  <div id="fb-root"></div>
  <script async defer crossorigin="anonymous" src="https://connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v3.2"></script>
  <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

  <script async defer src="https://buttons.github.io/buttons.js"></script>

</footer>

  </body>

</html>
